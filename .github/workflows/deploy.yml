name: Deploy Infrastructure & Application

on:
  workflow_dispatch:  # DÃ©clenchement manuel depuis GitHub UI

env:
  AWS_REGION: eu-west-3
  TF_VERSION: "1.2"
  REGISTRY: ghcr.io

jobs:
  # ============================================================================
  # JOB 1 : BUILD & PUBLISH
  # ============================================================================
  # Objectif: Construire l'image Docker de l'API et la pousser vers GHCR
  # Contrainte 1: Push vers le registre privÃ© (GHCR)
  # Contrainte 2: Aucun secret en clair (utilise GITHUB_TOKEN)
  # ============================================================================
  build:
    name: Build & Publish Docker Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry (GHCR)
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags and labels)
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/app-api
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      - name: Build and push API Docker image to GHCR
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./python.Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ðŸ“¦ Build Complete
        run: |
          echo "=========================================="
          echo "âœ… Images Docker construites et publiÃ©es vers GHCR"
          echo "=========================================="
          echo "Image: ${{ steps.meta.outputs.tags }}"
          echo "=========================================="


  # ============================================================================
  # JOB 2 : TERRAFORM
  # ============================================================================
  # Objectif: CrÃ©er l'infrastructure AWS (EC2, SG, clÃ© SSH)
  # Contrainte 1: AMI dynamique (pas hardcodÃ©e)
  # Contrainte 2: ClÃ© SSH gÃ©nÃ©rÃ©e Ã  la volÃ©e
  # Contrainte 3: Output IP publique pour Ansible
  # ============================================================================
  terraform:
    name: Terraform Plan & Apply
    runs-on: ubuntu-latest
    needs: build
    outputs:
      instance_ip: ${{ steps.tf_output.outputs.instance_ip }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Clean Up Existing AWS Resources
        run: |
          echo "ðŸ§¹ Nettoyage des ressources AWS existantes..."
          
          # Supprimer les instances EC2 existantes (avec le tag Terraform-App-FullStack)
          INSTANCE_IDS=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Terraform-App-FullStack" "Name=instance-state-name,Values=running,stopped" --query 'Reservations[].Instances[].InstanceId' --output text 2>/dev/null)
          if [ ! -z "$INSTANCE_IDS" ]; then
            echo "  - Suppression des instances EC2: $INSTANCE_IDS"
            aws ec2 terminate-instances --instance-ids $INSTANCE_IDS || true
            aws ec2 wait instance-terminated --instance-ids $INSTANCE_IDS 2>/dev/null || true
          fi
          
          # Supprimer la clÃ© SSH
          if aws ec2 describe-key-pairs --key-names app-key-terraform 2>/dev/null | grep -q "app-key-terraform"; then
            echo "  - Suppression de la clÃ© SSH: app-key-terraform"
            aws ec2 delete-key-pair --key-name app-key-terraform || true
          fi
          
          # Supprimer le Security Group
          SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=app-sg-fullstack" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null)
          if [ "$SG_ID" != "None" ] && [ ! -z "$SG_ID" ]; then
            echo "  - Suppression du Security Group: $SG_ID"
            sleep 30
            for i in {1..5}; do
              if aws ec2 delete-security-group --group-id $SG_ID 2>/dev/null; then
                echo "    âœ“ Security Group supprimÃ©"
                break
              else
                sleep 10
              fi
            done
          fi
          
          echo "âœ… Nettoyage terminÃ©"
        continue-on-error: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: infra
        run: terraform init

      - name: Terraform Validate
        working-directory: infra
        run: terraform validate

      - name: Terraform Plan
        working-directory: infra
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: infra
        run: terraform apply -auto-approve tfplan

      - name: Get Instance IP (Terraform Output)
        id: tf_output
        working-directory: infra
        run: |
          echo "=========================================="
          echo "ðŸ“ RÃ©cupÃ©ration de l'IP de l'instance..."
          echo "=========================================="
          
          INSTANCE_IP=$(terraform output -raw instance_ip)
          
          # Output pour les jobs suivants
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          
          echo "âœ… Instance IP: $INSTANCE_IP"
          echo "=========================================="


  # ============================================================================
  # JOB 3 : ANSIBLE (BRIDGE + DEPLOYMENT)
  # ============================================================================
  # Objectif: Configurer le serveur et dÃ©ployer l'application
  # Contrainte 1: RÃ©cupÃ©rer l'IP depuis Terraform
  # Contrainte 2: Utiliser la clÃ© SSH gÃ©nÃ©rÃ©e par Terraform
  # Contrainte 3: Docker login vers GHCR (registre privÃ©)
  # Contrainte 4: Pas de secret en clair
  # ============================================================================
  ansible:
    name: Ansible Deploy
    runs-on: ubuntu-latest
    needs: terraform
    env:
      INSTANCE_IP: ${{ needs.terraform.outputs.instance_ip }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: ðŸ”— Bridge Verification (Terraform -> Ansible)
        run: |
          echo "=========================================="
          echo "ðŸ”— VÃ©rification du pont Terraform -> Ansible"
          echo "=========================================="
          echo "Instance IP reÃ§ue: ${INSTANCE_IP}"
          
          if [ -z "${INSTANCE_IP}" ]; then
            echo "âŒ ERREUR: L'IP de l'instance n'a pas Ã©tÃ© transmise!"
            exit 1
          fi
          echo "âœ… IP valide reÃ§ue depuis Terraform"
          echo "=========================================="

      - name: Install Ansible & Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ansible paramiko

      - name: Retrieve SSH Key from Terraform
        working-directory: infra
        run: |
          # La clÃ© privÃ©e a Ã©tÃ© crÃ©Ã©e par Terraform lors du apply
          if [ ! -f app-key-terraform.pem ]; then
            echo "âŒ ERREUR: ClÃ© SSH non trouvÃ©e!"
            exit 1
          fi
          echo "âœ… ClÃ© SSH rÃ©cupÃ©rÃ©e depuis infra/"
          
          # Copier la clÃ© Ã  la racine pour Ansible
          cp app-key-terraform.pem ../app-key-terraform.pem

      - name: Set SSH Key Permissions
        run: |
          chmod 600 app-key-terraform.pem
          echo "âœ… Permissions de la clÃ© SSH dÃ©finie (chmod 600)"

      - name: Update Inventory with Dynamic IP
        run: |
          echo "=========================================="
          echo "ðŸ“ Mise Ã  jour de l'inventaire Ansible"
          echo "=========================================="
          
          # CrÃ©er inventaire dynamique avec l'IP de Terraform
          cat > inventory.ini << EOF
[app_hosts]
${INSTANCE_IP}

[app_hosts:vars]
ansible_user=ubuntu
ansible_ssh_private_key_file=./app-key-terraform.pem
ansible_ssh_common_args='-o StrictHostKeyChecking=no'
EOF
          
          echo "Contenu de l'inventaire:"
          cat inventory.ini
          echo "=========================================="

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << EOF
Host *
  StrictHostKeyChecking no
  UserKnownHostsFile=/dev/null
EOF
          chmod 600 ~/.ssh/config

      - name: ðŸš€ Run Ansible Playbook
        run: |
          echo "=========================================="
          echo "ðŸš€ ExÃ©cution du playbook Ansible"
          echo "=========================================="
          
          ansible-playbook -i inventory.ini ansible/playbook.yml -v \
            -e "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" \
            -e "GITHUB_ACTOR=${{ github.actor }}" \
            -e "GITHUB_REPOSITORY=${{ github.repository }}"
          
          echo "=========================================="
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'False'

      - name: âœ… Verify Deployment
        run: |
          echo ""
          echo "=========================================="
          echo "âœ… DÃ©ploiement terminÃ©!"
          echo "=========================================="
          echo "Instance IP: ${INSTANCE_IP}"
          echo ""
          echo "ðŸŒ AccÃ¨s Ã  l'application:"
          echo "   Frontend:   http://${INSTANCE_IP}:8080"
          echo "   API REST:   http://${INSTANCE_IP}:8000"
          echo "   API Docs:   http://${INSTANCE_IP}:8000/docs"
          echo ""
          echo "ðŸ—„ï¸  Services internes:"
          echo "   PostgreSQL: ${INSTANCE_IP}:5432"
          echo "   Redis:      ${INSTANCE_IP}:6379"
          echo "=========================================="


  # ============================================================================
  # JOB 4 : NOTIFY
  # ============================================================================
  # Objectif: Afficher un rÃ©sumÃ© final du dÃ©ploiement
  # ============================================================================
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [terraform, ansible]
    if: always()
    
    steps:
      - name: ðŸ“Š Deployment Status Summary
        run: |
          echo "=========================================="
          echo "ðŸ“Š RÃ‰SUMÃ‰ DU DÃ‰PLOIEMENT"
          echo "=========================================="
          
          TERRAFORM_STATUS="${{ needs.terraform.result }}"
          ANSIBLE_STATUS="${{ needs.ansible.result }}"
          INSTANCE_IP="${{ needs.terraform.outputs.instance_ip }}"
          
          echo "Terraform: $TERRAFORM_STATUS"
          echo "Ansible:   $ANSIBLE_STATUS"
          
          if [ "$TERRAFORM_STATUS" == "success" ] && [ "$ANSIBLE_STATUS" == "success" ]; then
            echo ""
            echo "âœ… SUCCÃˆS COMPLET!"
            echo ""
            echo "ðŸ”— AccÃ©dez Ã  l'application:"
            echo "   http://$INSTANCE_IP:8080"
            echo ""
            exit 0
          else
            echo ""
            echo "âŒ Ã‰CHEC DU DÃ‰PLOIEMENT"
            echo "   VÃ©rifiez les logs ci-dessus pour plus de dÃ©tails"
            exit 1
          fi
