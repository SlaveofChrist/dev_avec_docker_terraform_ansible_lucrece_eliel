name: Deploy Infrastructure & Application

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'main.tf'
      - 'playbook.yml'
      - 'inventory.ini'
      - 'docker-compose.yml'
      - 'python.Dockerfile'
      - 'requirements.txt'
      - 'app/**'
      - 'frontend/**'
      - 'sqlfiles/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:  # Permet de déclencher manuellement

env:
  AWS_REGION: eu-west-3
  TF_VERSION: "1.2"

jobs:
  terraform:
    name: Terraform Plan & Apply
    runs-on: ubuntu-latest
    outputs:
      instance_ip: ${{ steps.tf_output.outputs.instance_ip }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Clean Up Existing AWS Resources
        run: |
          echo "Nettoyage des ressources AWS existantes..."
          
          # Supprimer les instances EC2 existantes
          INSTANCE_IDS=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Terraform-App-FullStack" "Name=instance-state-name,Values=running,stopped" --query 'Reservations[].Instances[].InstanceId' --output text 2>/dev/null)
          if [ ! -z "$INSTANCE_IDS" ]; then
            echo "Suppression des instances EC2: $INSTANCE_IDS"
            aws ec2 terminate-instances --instance-ids $INSTANCE_IDS || true
            aws ec2 wait instance-terminated --instance-ids $INSTANCE_IDS 2>/dev/null || true
            echo "Instances terminées."
          fi
          
          # Supprimer la clé SSH si elle existe
          if aws ec2 describe-key-pairs --key-names app-key-terraform 2>/dev/null | grep -q "app-key-terraform"; then
            echo "Suppression de la clé SSH: app-key-terraform"
            aws ec2 delete-key-pair --key-name app-key-terraform || true
          fi
          
          # Supprimer le Security Group (attendre que les interfaces réseau soient libérées)
          SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=app-sg-fullstack" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null)
          if [ "$SG_ID" != "None" ] && [ ! -z "$SG_ID" ]; then
            echo "Security Group trouvé: $SG_ID"
            # Attendre 30 secondes que les instances soient complètement libérées
            echo "Attente de 30 secondes avant suppression du Security Group..."
            sleep 30
            
            # Essayer de supprimer le SG plusieurs fois
            for i in {1..5}; do
              if aws ec2 delete-security-group --group-id $SG_ID 2>/dev/null; then
                echo "Security Group supprimé avec succès."
                break
              else
                echo "Tentative $i échouée. Nouvelle tentative dans 10 secondes..."
                sleep 10
              fi
            done
          fi
          
          echo "Nettoyage terminé."
        continue-on-error: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init (Check State)
        run: terraform init
        working-directory: ${{ github.workspace }}
        continue-on-error: true

      - name: Destroy Existing Resources
        run: |
          if [ -f terraform.tfstate ]; then
            echo "État Terraform trouvé. Destruction des ressources existantes..."
            terraform destroy -auto-approve
          else
            echo "Aucun état Terraform existant. Pas de destruction nécessaire."
          fi
        working-directory: ${{ github.workspace }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        run: terraform init
        working-directory: ${{ github.workspace }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ github.workspace }}

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: ${{ github.workspace }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ${{ github.workspace }}

      - name: Get Instance IP
        id: tf_output
        run: |
          echo "=========================================="
          echo "Récupération de l'IP de l'instance EC2..."
          echo "=========================================="
          
          INSTANCE_IP=$(terraform output -raw instance_ip 2>/dev/null)
          INSTANCE_IP=$(echo $INSTANCE_IP | sed 's/::.*//')
          
          # Stockage dans les outputs (pour le job notify)
          echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
          
          # Stockage dans GITHUB_ENV (accessible dans les étapes du Terraform job)
          echo "INSTANCE_IP=${INSTANCE_IP}" >> $GITHUB_ENV
          
          echo "✅ Instance IP extraite: ${INSTANCE_IP}"
        working-directory: ${{ github.workspace }}
        env:
          TF_LOG: off

      - name: Save Terraform State (Artifact)
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: terraform.tfstate

  ansible:
    name: Ansible Deploy
    runs-on: ubuntu-latest
    needs: terraform
    env:
      # Récupération de l'IP créée par Terraform (disponible dans tout le job)
      INSTANCE_IP: ${{ needs.terraform.outputs.instance_ip }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Verify Instance IP Passed
        run: |
          echo "=========================================="
          echo "Vérification du pont Terraform -> Ansible"
          echo "=========================================="
          echo "Instance IP reçue: ${INSTANCE_IP}"
          
          if [ -z "${INSTANCE_IP}" ]; then
            echo "❌ ERREUR: L'IP de l'instance n'a pas été transmise!"
            exit 1
          fi
          echo "✅ IP valide reçue depuis Terraform"

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible paramiko

      - name: Update inventory.ini with Instance IP
        run: |
          echo "=========================================="
          echo "Mise à jour de l'inventory.ini"
          echo "=========================================="
          echo "Utilisation de l'IP: ${INSTANCE_IP}"
          
          # Backup de l'inventory original
          cp inventory.ini inventory.ini.bak
          
          # Remplacement de l'IP dynamiquement
          sed -i "s/^# Cette IP sera remplacée par la sortie de main.tf$/# Instance IP: ${INSTANCE_IP}/" inventory.ini
          sed -i "s/^13\.39\.13\.141$/${INSTANCE_IP}/" inventory.ini
          sed -i "s/^[0-9.]\{7,15\}$/${INSTANCE_IP}/" inventory.ini
          
          echo "Contenu de l'inventory.ini mis à jour:"
          cat inventory.ini

      - name: Download SSH Key from Terraform
        run: |
          ls -la app-key-terraform.pem 2>/dev/null || echo "SSH key will be created by terraform"

      - name: Set SSH Key Permissions
        run: |
          if [ -f app-key-terraform.pem ]; then
            chmod 600 app-key-terraform.pem
          fi

      - name: Update SSH Config
        run: |
          mkdir -p ~/.ssh
          echo "Host *" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile=/dev/null" >> ~/.ssh/config
          chmod 600 ~/.ssh/config

      - name: Run Ansible Playbook
        run: |
          ansible-playbook -i inventory.ini playbook.yml -v
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'False'

      - name: Verify Deployment
        run: |
          echo ""
          echo "=========================================="
          echo "Déploiement terminé!"
          echo "=========================================="
          echo "Instance IP utilisée: ${INSTANCE_IP}"
          echo ""
          echo "Accès à l'application:"
          echo "  Frontend:   http://${INSTANCE_IP}:8080"
          echo "  API REST:   http://${INSTANCE_IP}:8000"
          echo "  PostgreSQL: ${INSTANCE_IP}:5432"
          echo "  Redis:      ${INSTANCE_IP}:6379"
          echo "=========================================="

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [terraform, ansible]
    if: always()
    
    steps:
      - name: Check Deployment Status
        run: |
          if [ "${{ needs.terraform.result }}" == "success" ] && [ "${{ needs.ansible.result }}" == "success" ]; then
            echo "✅ Deployment successful!"
            echo "Instance IP: ${{ needs.terraform.outputs.instance_ip }}"
            exit 0
          else
            echo "❌ Deployment failed!"
            exit 1
          fi
